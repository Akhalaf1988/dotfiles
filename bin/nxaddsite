#! /usr/bin/env bash

# Script Arguments
  ARGA=("$@")
  DOMAIN=""
  FILE=""

_usage() {

# Print help
  cat <<- EOF

Description: Site Creation Tool For Nexcess Cloud Servers.
Requires: Nocworx api-token
Usage: nxaddsite -d

   Supported Options:

     -d|--domain   Add Domain
     -f|--file     TXT File With List Of Domains
     -h|--help     Display This Message

EOF
}

_normalize_domain(){

  local sed_args

  sed_args=(-e 's/https?:\/\///' -e 's/\/.*//' -e 's,\.$,,')
# Strip URL of any extra slashes
  echo "$1" | sed -r "${sed_args[@]}" | tr '[:upper:]' '[:lower:]'

}

_delete_api_token(){

  printf "Deleting client api-token..."

# Reset Headers
  headers=("${headers[@]:0:0}")

# Add new header
  headers=(
    -H "Authorization: Bearer ${NWTOKEN}"
    -H "Content-type: application/json"
    -H "Accept: application/json"
   )

# delete token api request
   curl -sX DELETE "${api_url}${token_endpoint}/${client_token_id}" "${headers[@]}"
   printf "done\n"
}

_create_site(){

  domain="$1"
# set legacy endpoints
  legacy_api_url='https://portal.nexcess.net/'
  legacy_endpoint='cloud-account'

# Extract app_id from siteworx data
  app_id=$(echo "${siteworx}" | grep 'app_id' | awk '{print $2}');

# Reset Headers
  headers=("${headers[@]:0:0}")

# create new header because we need clients api token for this call.

  headers=(
    -H "Authorization: Bearer ${client_token_value}"
    -H "Accept: application/json"
    -H "Accept: application/json"
    -d "{\"service_id\": \"${service_id}\", \"install_app\": \"on\",\"nickname\": \"${domain}\"}"
 )
  printf "%sCreating ${domain}\n"
###todo


# Create site with POST request to legacy api
  curl-L -X POST "${legacy_api_url}${legacy_endpoint}" "${header[@]}"

# sleep for 5 seconds to give api time.
  sleep 5

}

# Function to process domains from a file
_process_domains() {

    # Read each domain from the file, normalize domain and create site
    while IFS= read -r domain; do
        normalized_domain=$(_normalize_domain "${domain}")
       _create_site "$normalized_domain"
    done < "$file"
}

_create_api_token(){

  printf "Creating client api-token..."
# Set Token Endpoint
  token_endpoint="${acc_id}/v1/api-token"

# Add additional elements to header array
  headers+=(
    -H "Content-type: application/json"
    -d "{\"name\":\"nxaddsite-token\"}"
     )

# Create Cleint api token and save it as a var
  token_resp=$(curl -sX POST "${api_url}${token_endpoint}" "${headers[@]}");

# Extract Token ID and Value from token_resp
  client_token_id=$(echo "${token_resp}" | jq -r '.id');
  client_token_value=$(echo "${token_resp}" | jq -r '.token');
  printf "done\n"

  case "${DOMAIN}" in
      "YES")
          _create_site "${domain}"
          ;;
      *)
          _process_domains
          ;;
  esac
}


_site_info(){

  printf "Checking Site Info..."
# Extract app_id from siteworx data
  app_id=$(echo "${siteworx}" | grep 'app_id' | awk '{print $2}');

# Check app_id to confirm we are working with wordpress or woo-commerce
  case ${app_id} in
      17 | 19)
          printf "done\n"
          ;;
      *)
          printf "done\n"
          printf "Functionality is designed only for WordPress/Woo and Magento environments.\n"
          exit 1
          ;;
  esac

}

_site_count(){

# Remove the elements for headers array we don't want from existing array in check_api
# should remove -w "%{http_code}" and -o "/dev/null"

  headers=("${headers[@]:0:2}")
# add new elements to header array
  headers=+(
    -H "Accept: application/json"
  )

  printf "Site Check..."

# Extract service_id and package_id from Siteworx data
  service_id=$(echo "${siteworx}" | grep 'service_id' | awk '{print $2}');
  package_id=$(echo "${siteworx}" | grep 'package_id' | awk '{print $2}');

# Set Endpoints
  site_count_endpoint="${acc_id}/v1/service/site/${service_id}"
  site_total_endpoint="${acc_id}/v1/package/site/${package_id}"

# Fetch site data from API
  site_count=$(curl -s "${api_url}${site_count_endpoint}" "${headers[@]}" | jq -r '.sites[].identity' | wc -l);
  site_total=$(curl -s "${api_url}${site_total_endpoint}" "${headers[@]}" | jq -r '.primary_accounts');
  printf "done\n"

# Print site usage information
  printf "%sSites Used (${site_count}/${site_total})\n"

# Determine extra domains/sites
  if [[ "${DOMAIN}" == "YES" ]]; then
      extra_domain="1"
  else
      extra_domain=$(wc -l < "${file}")
  fi

# Calculate total sites
  total_sites=$((site_count + extra_domain))

# Check if plan can accommodate additional sites
  if [[ "${total_sites}" -gt "${site_total}" ]]; then
     printf "%sThis plan can only fit ${site_total} site(s), please upgrade to fit ${total_sites}\n"
     exit 1
  fi

}

_check_api(){

# Declare local variables
  local resp

# Define siteworx var
  siteworx=$(sudo -u iworx /usr/local/interworx/bin/config.pex --list --siteworx "${dom}");

# Extract site ID and account ID from siteworx data
  site_id=$(echo "${siteworx}" | grep 'account_id' | awk '{print $2}');
  acc_id=$(echo "${siteworx}" | grep '^client_id' | awk '{print $2}');

# Set headers for the API request
  headers=(
    -H "Authorization: Bearer ${NWTOKEN}"
    -H "Accept: application/json"
    -w "%{http_code}"
    -o "/dev/null"
  )
# I want to hit a less impactful endpoint to test the api token
# Set API URL and client endpoint
  api_url='https://nocworx.nexcess.net/api/v1/as-client/'
  client_endpoint="${acc_id}/v1/client"

  printf "\nChecking api-key..."

# Send curl to check api response
  resp=$(curl --silent "${api_url}${client_endpoint}" "${headers[@]}");

# Check reponse code. If not 200 get host and port info
# Else try to get the container info with api info
  if [[ "${resp}" -ne 200 ]]; then
     printf "done\n"
     printf "%sAPI Token  not valid ${resp}\n";
     exit 1
  else
     printf "done\n"
  fi

}

# Description: Validates input against a specified pattern.
# Parameters:
# input: The input string to be validated.
# pattern: The regular expression pattern used for validation.
# Returns:
# 0 if the input matches the pattern (valid input).
# 1 if the input does not match the pattern (invalid input).

_validate_input(){

# Declare local variables for input and pattern
  local input pattern

# Assign input and pattern from function parameters
  input="$1"
  pattern="$2"

# Check if input matches the pattern using regular expression
  if [[ ! "${input}" =~ ${pattern} ]]; then
      # Print error message if input does not match the pattern
      printf "Error: Invalid input. Please try again\n"
      # Return 1 to indicate invalid input
      return 1
  fi
# Return 0 to indicate valid input
  return 0

}

# Description: Validates user input for domain and file paths.
_check_user_input(){

# Define regular expression patterns for domain and file paths
  host_pattern="^[^.|*].*$"
  path_pattern="^[^*]+$"

# Check for mutually exclusive options and handle accordingly
  case "${FILE}-${DOMAIN}" in
      YES-YES)
          # Print error message if both FILE and DOMAIN are set to YES
          printf "You Can Only Select One Option, See Help Section.\n"
          # Exit with error status 1
          exit 1
          ;;
      *)
          # No conflict between options, continue processing
          ;;
  esac
# Validate domain input if DOMAIN is set to YES
  case "${DOMAIN}" in
        YES)
            while true; do
                # Prompt user for domain input
                read -r -p "Domain: " domain
                # Validate domain input against host pattern
                if ! _validate_input "${domain}" "${host_pattern}"; then
                    continue # Continue loop if input is invalid
                fi
                # Normalize domain input (if needed)
                domain="$(_normalize_domain "${domain}")"
                break # Break out of loop if input is valid
            done
            ;;
        *)
            # DOMAIN is not set to YES, skip domain validation
            ;;
    esac

# Validate file path input if FILE is set to YES
    case "${FILE}" in
        YES)
            while true; do
                # Prompt user for file path input
                read -r -p "Path To Domain.txt File: " file
                # Validate file path input against path pattern
                if ! _validate_input "${file}" "${path_pattern}"; then
                    continue # Continue loop if input is invalid
                fi
                # Check if file exists and is not empty
                if [ ! -s "${file}" ]; then
                    printf "%sFile ${file} Does Not Exist Or Is Empty.\n"
                    # Exit with error status 1 if file is missing or empty
                    exit 1
                fi
                break # Break out of loop if input is valid
            done
            ;;
        *)
            # FILE is not set to YES, skip file path validation
            ;;
    esac
}

_cmdline() {

  local x;

  for x in "${ARGA[@]}"; do

    case "$x" in
     "--domain"|"-d")
        args="${args}-d "
        ;;
     "--file"|"-f")
        args="${args}-f "
        ;;
     "--help"|"-h")
        args="${args}-h "
        ;;
      "--"*)
        echo "$x is not a supported option." >&2
        ;;
      *)
        args="${args}${x} "
        ;;
    esac
  done

  echo "$args";

}

main(){

  local cmdline;

  mapfile -t cmdline < <(_cmdline | tr ' ' '\n');

  while getopts ":dfh" OPTION "${cmdline[@]}"; do

    case $OPTION in
      d)
        DOMAIN="YES";
        ;;
      f)
        FILE="YES";
        ;;
      h)
        _usage;
        exit 0;
        ;;
     "?")
        echo "-${OPTARG} is not a supported option." >&2
        ;;
      *);;
    esac
  done

# Set variables for the domain information

  user="$(pwd | grep -Po "/(chroot/)?home/\K[^/]*")";
  dom="$(pwd| grep -Po "/(chroot/)?home/${user}/\K[^/]*")";
  vhost=$(find /etc/httpd/conf.d/ -type f -iname "vhost_${dom}.conf")

# Make sure we are in a domain directory.
  case "${vhost}" in
      "")
          printf "Vhost Not found, Make sure you are in a domain directory.\n"
          exit 1
          ;;
      *)
          ;;
  esac

# Check for NWTOKEN
  case "${NWTOKEN}" in
      "")
          read -r -p "Enter API-TOKEN: " api_token
          NWTOKEN="${api_token}"
          ;;
      *)
          ;;
  esac


# Verify Input
  _check_user_input

# Verify admin api token works
  _check_api

# Determine if sites can fit on existing plan
  _site_count

# Determine app id
  _site_info

# Create customer api token
#  _create_api_token

}

main
