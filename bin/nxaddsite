#! /usr/bin/env bash

# Script Arguments
  ARGA=("$@")
  DOMAIN=""
  FILE=""

_usage() {

# Print help
  cat <<- EOF

Description: Site Creation Tool For MWP and Magento.
Requires: Nocworx api-token
Usage: nxaddsite -d domain.com; nxaddsite -f file.txt

   Supported Options:

     -d|--domain   Create a site
     -f|--file     Create muliple domains from a file.
     -h|--help     Display This Message

EOF

}

_normalize_domain(){

  local sed_args

  sed_args=(-e 's/https?:\/\///' -e 's/\/.*//' -e 's,\.$,,')

# Strip URL of any extra slashes
  echo "$1" | sed -r "${sed_args[@]}" | tr '[:upper:]' '[:lower:]'

}

_delete_api_token(){

  printf "deleting client api-token..."

# delete token api request

  if ! curl -sX DELETE "${api_url}${token_endpoint}/${client_token_id}" "${headers[@]}" >/dev/null 2>&1; then
      printf "done\n"
      printf "Failed to delete TokenID: %s\n" "${client_token_id}"
  else
      printf "done\n"
  fi

}

scan_site(){

  local end found new_site_data new_site_list new_site_count new_domain
# Reset Headers to exclude -d
  headers=("${headers[@]:0:6}")

  end=$((SECONDS+5))
  found=false

# Kind of janky workaround to get the new domain. This api endpoint does not give a task uri so we are left
# With a best guess. We are going to grab the list of sites and count them, if the number is greater than our inital list show the last one which should be the newly added domain

 while [ ${SECONDS} -lt ${end} ]; do

     new_site_data=$(curl -s "${api_url}${service_data_endpoint}" "${headers[@]}");
     if [[ "${app_id}" == "11" ]]; then
        new_site_list=$(echo "${new_site_data}" | jq -r '.sites[].identity, .child_sites[].identity');
     else
        new_site_list=$(echo "${new_site_data}" | jq -r '.sites[].identity');
     fi
     new_site_count=$(echo "${new_site_list}" | wc -l);
     if [[ "${new_site_count}" -gt "${site_count}" ]]; then
         new_domain=$(echo "${new_site_list}" | tail -n1);
          printf "%s: %s\n" "${domain}" "${new_domain}"
         found=true
         break
     fi
     sleep 1  # Sleep for 1 second before trying again
 done

# If no new domain found after the loop
  if [ "${found}" = false ]; then
      printf "unable to find new domain\n"
  fi

}

_create_site(){

  local legacy_api_url legacy_endpoint client_headers
  domain="$1"

# set legacy endpoints
  legacy_api_url='https://portal.nexcess.net/'
  legacy_endpoint='cloud-account'

# create new header because we need clients api token for this call.
  client_headers=(
    -H "Authorization: Bearer ${client_token_value}"
    -H "Content-Type: application/json"
    -H "Accept: application/json"
 )

  if [[ "${app_id}" == "11" ]]; then
    legacy_endpoint="cloud-account/${site_id}"
    client_headers+=(
         -d "{\"nickname\": \"${domain}\", \"app_id\": \"${app_id}\", \"install_app\": \"off\", \"_action\": \"add-child-account\"}")
  else
    legacy_endpoint='cloud-account'
    client_headers+=(
         -d "{\"service_id\": \"${service_id}\", \"install_app\": \"on\",\"nickname\": \"${domain}\"}")
  fi

  if ! curl -sLX POST "${legacy_api_url}${legacy_endpoint}" "${client_headers[@]}" >/dev/null 2>&1; then
      printf "Failed to create %s" "${domain}\n"
  else
      scan_site
  fi

}

_process_domains() {

# Read each domain from the file, normalize domain and create site
  printf "processing domains from %s\n" "${file}"
  while IFS= read -r domain; do
      normalized_domain=$(_normalize_domain "${domain}")
      _create_site "${normalized_domain}"
      sleep 5
  done < "${file}"

}

_create_api_token(){

  printf "creating client api-token..."
# Set Token Endpoint
  token_endpoint="${acc_id}/v1/api-token"

# Add additional elements to header array
  headers+=(
    -H "Content-type: application/json"
    -d "{\"name\":\"nxaddsite-token\"}"
     )

# Check if the curl command succeeded
  if ! token_resp=$(curl -sX POST "${api_url}${token_endpoint}" "${headers[@]}"); then
      printf "done\n"
      printf "failed to create client api-token"
      exit 1
  else
     # Extract Token ID and Value from token_resp
     client_token_id=$(echo "${token_resp}" | jq -r '.id');
     client_token_value=$(echo "${token_resp}" | jq -r '.token');
     printf "done\n"
  fi

}

_site_count(){

  local  site_total extra_domain total_sites

  printf "checking plan capacity..."

# Check app_id to confirm we are working with wordpress or woo-commerce
  case ${app_id} in
      17 | 19)
          initial_site_list=$(echo "${service_data}" | jq -r '.sites[].identity');
          site_total=$(echo "${package_data}" | jq -r '.primary_accounts');
          ;;
      11)
          initial_site_list=$(echo "${service_data}" | jq -r '.sites[].identity, .child_sites[].identity');
          site_total=$(echo "${package_data}" | jq -r '.child_accounts');
          site_total=$((site_total + 1));
          ;;
      *)
          printf "done\n"
          printf "functionality is designed only for WordPress/Woo and Magento environments.\n"
          exit 1
          ;;
  esac

  site_count=$(echo "${initial_site_list}" | wc -l);

# Determine extra domains/sites
  if [[ "${DOMAIN}" == "YES" ]]; then
      extra_domain="1"
  else
      extra_domain=$(wc -l < "${file}")
  fi

# Calculate total sites
  total_sites=$((site_count + extra_domain))

# Check if plan can accommodate additional sites
  if [[ "${total_sites}" -gt "${site_total}" ]]; then
     printf "done\n"
     printf "site limit reached, please upgrade to fit %s\n" "${total_sites}"
     exit 1
  fi
  printf "done %d/%d\n" "${site_count}" "${site_total}"

}

_get_site_info(){
  local plan_name
  printf "Getting site info..."

# remove -w "%{http_code}" and -o "/dev/null"
  headers=("${headers[@]:0:2}")

# add new element to header array
  headers+=(
    -H "Accept: application/json"
  )

# Extract service_id and package_id from Siteworx data
  service_id=$(echo "${siteworx}" | grep 'service_id' | awk '{print $2}');
  package_id=$(echo "${siteworx}" | grep 'package_id' | awk '{print $2}');
  app_id=$(echo "${siteworx}" | grep 'app_id' | awk '{print $2}');
  site_id=$(echo "${siteworx}" | grep 'account_id' | awk '{print $2}');

# Set service and package endpoints
  service_data_endpoint="${acc_id}/v1/service/site/${service_id}"
  package_data_endpoint="${acc_id}/v1/package/site/${package_id}"
# Save data
  service_data=$(curl -s "${api_url}${service_data_endpoint}" "${headers[@]}");
  package_data=$(curl -s "${api_url}${package_data_endpoint}" "${headers[@]}");
  plan_name=$(echo "${service_data}" | jq -r '.identity');
  printf "done\n"

  printf "AccountID: %s\n" "${acc_id}"
  printf "Plan Name: %s\n" "${plan_name}"
  printf "ServiceID: %s\n" "${service_id}"
}

_check_api(){

  local resp

# Extract site ID and account ID from siteworx data
  acc_id=$(echo "${siteworx}" | grep '^client_id' | awk '{print $2}');

# Set headers for the API request
  headers=(
    -H "Authorization: Bearer ${NWTOKEN}"
    -H "Accept: application/json"
    -w "%{http_code}"
    -o "/dev/null"
  )
# Goal: hit a less impactful endpoint to test the api token
# Set API URL and client endpoint
  api_url='https://nocworx.nexcess.net/api/v1/as-client/'
  client_endpoint="${acc_id}/v1/client"

  printf "authenticating NWTOKEN..."

# Send curl to check api response
  resp=$(curl --silent "${api_url}${client_endpoint}" "${headers[@]}");

# Check reponse code. If not 200 get host and port info
# Else try to get the container info with api info
  if [[ "${resp}" -ne 200 ]]; then
     printf "done\n"
     printf "authentication Failed %s\n" "${resp}";
     exit 1
  else
     printf "done\n"
  fi

}

_cmdline() {

  local x;

  for x in "${ARGA[@]}"; do

    case "$x" in
     "--domain"|"-d")
        args="${args}-d "
        ;;
     "--file"|"-f")
        args="${args}-f "
        ;;
     "--help"|"-h")
        args="${args}-h "
        ;;
      "--"*)
        echo "$x is not a supported option." >&2
        ;;
      *)
        args="${args}${x} "
        ;;
    esac
  done

  echo "$args";
}

main(){

  local cmdline;

  mapfile -t cmdline < <(_cmdline | tr ' ' '\n');

  while getopts ":d:f:h" OPTION "${cmdline[@]}"; do

    case $OPTION in
      d)
        DOMAIN="YES"
        domain=$(_normalize_domain "${OPTARG}")
        ;;
      f)
        FILE="YES"
        file="${OPTARG}"
          if [ ! -s "${file}" ]; then
            printf "%s Does Not Exist Or Is Empty.\n" "${file}"
            exit 1
        fi;
        ;;
      h)
        _usage;
        exit 0;
        ;;
     "?")
        echo "-${OPTARG} is not a supported option." >&2
        ;;
      *);;
    esac
  done

  case "${DOMAIN}${FILE}" in
    "YESYES")
        printf "Only one option can be selected.\n"
        exit 1
        ;;
    *)
        ;;
  esac

  if [[ ! $(hostname) =~ cloudhost ]]; then
      printf "nxaddsite is only available on Nexcess Cloud Servers\n";
      exit 1;
  fi

# Set variables for the domain information
  user="$(pwd | grep -Po "/(chroot/)?home/\K[^/]*")";
  dom="$(pwd| grep -Po "/(chroot/)?home/${user}/\K[^/]*")";
  vhost=$(find /etc/httpd/conf.d/ -type f -iname "vhost_${dom}.conf")

# Define siteworx var
  siteworx=$(sudo -u iworx /usr/local/interworx/bin/config.pex --list --siteworx "${dom}");

# Make sure we are in a domain directory.
  case "${vhost}" in
      "")
          printf "Vhost Not found, Make sure you are in a domain directory.\n"
          exit 1
          ;;
      *)
          ;;
  esac

# Check for NWTOKEN
  case "${NWTOKEN}" in
      "")
          read -r -p "Enter API-TOKEN: " api_token
          NWTOKEN="${api_token}"
          ;;
      *)
          ;;
  esac

# Verify admin api token works
  _check_api
# check plan for site details
 _get_site_info

# Determine if sites can fit on existing plan
  _site_count

# Create customer api token
  _create_api_token

  case "${DOMAIN}" in
      "YES")
          printf "creating %s\n" "${domain}"
          _create_site "${domain}"
          ;;
      *)
          _process_domains
          ;;
  esac

# Delete customer created api token
  _delete_api_token

}

main
